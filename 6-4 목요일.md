# Classes
[MDN : Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)

## Sub classing with `extends`

`extends` 키워드는 class 선언(혹은 class 표현식) 안에 사용되며 다른 클래스의 자식 클래스를 생성합니다.

```javascript
class Animal { 
  constructor(name) { // 인스턴스 생성시 인자를 받아 .name 속성에 등록
    this.name = name;
  }
  
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // 수퍼클래스의 constructor를 호출하며, name을 인자로 전달합니다.
  }

  speak() { // Animal class의 speak 메서드를 override함.
    console.log(this.name + ' barks.');
  }
}

let d = new Dog('Mitzie');
d.speak(); // Mitzie barks.
```
만약 서브클래스에 constructor가 존재하면, "this"를 사용하기 전에 super()를 호출해야 합니다.

전통적인 function-based "classes" 역시 extend할 수 있습니다. :
```js
function Animal (name) {
  this.name = name;  
}

Animal.prototype.speak = function () {
  console.log(this.name + ' makes a noise.');
}

// constructor 함수와 prototype 속성에 메서드를 넣어둠.
// 이렇게 만든것도 class 선언시 extends로 가져?올수있다.

class Dog extends Animal {
  speak() { // 기존 메서드 override
    console.log(this.name + ' barks.');
  }
}

let d = new Dog('Mitzie');
d.speak(); // Mitzie barks.
```



## Super class calls with `super`

`super` 키워드는 수퍼클래스의 관련 메서드를 호출하는데 사용됩니다. 프로토타입 기반의 상속 방식에 비해 장점이 되는 부분입니다.

```js
class Cat { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Lion extends Cat {
  speak() { // speak 메서드를 override
    super.speak(); // 수퍼클래스의 speak메서드를 가져와 호출
    console.log(`${this.name} roars.`);
  }
}

let l = new Lion('Fuzzy');
l.speak(); 
// Fuzzy makes a noise.
// Fuzzy roars.
```

# Super

[MDN : Super] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)

**super** 키워드는 부모 오브젝트의 함수에 액세스하고 호출하기 위해 사용됩니다.

## Description
constructor 안에서 사용될 때, super 키워드는 하나만 존재해야 하며 반드시 `this`키워드가 사용되기 전에 사용되어야 합니다. super 키워드는 또한 부모 오브젝트의 함수를 호출하기 위해서도 사용될 수 있습니다.




<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1NDE0MTQyNjQsLTExMjE2NjIwMzZdfQ
==
-->